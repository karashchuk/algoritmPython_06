# Задание 1.
# Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых трех уроков.
# Проанализировать результат и определить программы с наиболее эффективным использованием памяти.
# Примечание: По аналогии с эмпирической оценкой алгоритмов идеальным решением будет:
# a. выбрать хорошую задачу, которую имеет смысл оценивать по памяти;
# b. написать 3 варианта кода (один у вас уже есть);
# проанализировать 3 варианта и выбрать оптимальный;
#
# c. результаты анализа (количество занятой памяти в вашей среде разработки) вставить в виде комментариев в
# файл с кодом. Не забудьте указать версию и разрядность вашей ОС и интерпретатора Python;
# d. написать общий вывод: какой из трёх вариантов лучше и почему.
# Надеемся, что вы не испортили программы, добавив в них множество sys.getsizeof после каждой переменной, а проявили
# творчество, фантазию и создали универсальный код для замера памяти.

import sys
print(f'Версия Python: {sys.version}\nОС: {sys.platform}')

def show_size(x,level = 0): # определим функцию для вычисления размера объекта
    sizeof = sys.getsizeof(x)
    # print('\t'*level ,f'object = {x}, type = {x.__class__}, size = {sys.getsizeof(x)}')
    if hasattr(x, '__iter__'):
        if hasattr(x, 'items'):
            for k, v in x.items():
                sizeof += show_size(k, level + 1)
                sizeof += show_size(v, level + 1)
        elif not isinstance(x, str):
            for i in x:
                sizeof += show_size(i, level + 1)
    return sizeof


# а. для проверки выделения памяти возьмем задачу 9 из Урока 2. Данная задача интересна тем что реализуется разными
# методами с разным количеством переменных.

# Задание 9 из 2 урока.
# Среди натуральных чисел, которые были введены, найти наибольшее по сумме цифр. Вывести на экран это число и сумму
# его цифр.

# b. реализуем каждый из способов в виде отдельной функции, чтобы было можно сравнивать. и модернизируем задачу тем что
# на вход везде будем подавать один и тот же список

lst = [123456, 998, 102374, 54002,1200000001]
#print(show_size(lst))

def s_num_cycle(l):
    max_num = 0
    max_sum = 0
    for i in l:
        sm = 0
        k = i
        while i > 0:
            sm += int((i % 10))
            i //= 10
        if sm > max_sum:
            max_num = k
            max_sum = sm
    all = locals().copy()
    mem = 0
    for i,v in all.items():
        mem += show_size(v)
    return mem #(max_num, max_sum)

def s_str_cycle(l):
    ls = [list(str(i)) for i in l]
    max_num = 0
    max_sum = 0
    for i in range(len(ls)):
        summ = 0
        for x in ls[i]:
            summ +=int(x)
        if summ > max_sum:
            max_sum = summ
            max_num = l[i]
    all = locals().copy()
    mem = 0
    for i,v in all.items():
        mem += show_size(v)
    return mem #(max_num, max_sum)

def s_str_map(l):
    # ls = list(map(lambda x: str(x), l))
    # ln = list(map(lambda y: sum(list(map(lambda x: int(x), list(y)))), ls))
    ln = list(map(lambda y: sum(list(map(lambda x: int(x), list(y)))), list(map(lambda x: str(x), l))))
    max_sum = max(ln)
    max_num = l[ln.index(max_sum)]
    all = locals().copy()
    mem = 0
    for i,v in all.items():
        mem += show_size(v)
    return mem #(max_num, max_sum)

print('Работа с исходным списком чисел, обработка каждого в цикле. Размер: ', s_num_cycle(lst))
print('Перевод чисел в строки и разбивка на последовательности сначала строк, потом чисел. Размер:' , s_str_cycle(lst))
print('С помощью map сразу формируем последовательность сумм цифер в числах. Размер: ', s_str_map(lst))

# c. результаты анализа (количество занятой памяти в вашей среде разработки) вставить в виде комментариев в
# файл с кодом. Не забудьте указать версию и разрядность вашей ОС и интерпретатора Python;

# Версия Python: 3.7.7 (tags/v3.7.7:d7c567b08f, Mar 10 2020, 10:41:24) [MSC v.1900 64 bit (AMD64)]
# ОС: win32

# Работа с исходным списком чисел, обработка каждого в цикле. Размер:  388
# Перевод чисел в строки и разбивка на последовательности сначала строк, потом чисел. Размер: 2750
# С помощью map сразу формируем последовательность сумм цифер в числах. Размер:  572

# d. написать общий вывод: какой из трёх вариантов лучше и почему.

# Вывод: самым оптимальным с точки зрения выделения памяти оказался первый вариант, который реализовал
# в цикле работу только с исходным списком. Поэтому кроме размера памяти под исходый список выделялась память
# только для переменных в цикле.
# На втором месте (размер памяти примерно в 1.5 раза больше - реализация с помощью map. С помощью этой функции
# преобразовали сначала в str, потом список сиволов, обратно перевод в список чисели и сразу просуммировал список чисел.
# В итоге получился список сумм, по которому просто вычислил максимум и взял индекс для определения самого числа.
# Существенно больше памяти занял вариант с постепенным переводом чисел в строку, последовательность символов,
# в результате получилась последовательноть последовательностей сиволов, что занимает очень много памяти.